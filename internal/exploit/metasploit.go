package exploit

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

type MetasploitClient struct {
	baseURL string
	token   string
	client  *http.Client
}

type MetasploitConfig struct {
	Host     string
	Port     int
	Username string
	Password string
	SSL      bool
}

type ExploitRequest struct {
	Module  string            `json:"module"`
	Target  string            `json:"target"`
	Payload string            `json:"payload"`
	Options map[string]string `json:"options"`
}

type ExploitResult struct {
	Success    bool      `json:"success"`
	SessionID  string    `json:"session_id"`
	Output     string    `json:"output"`
	Module     string    `json:"module"`
	Target     string    `json:"target"`
	Timestamp  time.Time `json:"timestamp"`
}

func NewMetasploitClient(config MetasploitConfig) (*MetasploitClient, error) {
	protocol := "http"
	if config.SSL {
		protocol = "https"
	}
	baseURL := fmt.Sprintf("%s://%s:%d/api", protocol, config.Host, config.Port)
	client := &MetasploitClient{
		baseURL: baseURL,
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
	if err := client.authenticate(config.Username, config.Password); err != nil {
		return nil, fmt.Errorf("error de autenticación: %w", err)
	}
	return client, nil
}

func (mc *MetasploitClient) authenticate(username, password string) error {
	payload := map[string]string{
		"username": username,
		"password": password,
	}
	response, err := mc.makeRequest("auth.login", payload)
	if err != nil {
		return err
	}
	var result struct {
		Result string `json:"result"`
		Token  string `json:"token"`
	}
	if err := json.Unmarshal(response, &result); err != nil {
		return fmt.Errorf("error parseando respuesta: %w", err)
	}
	if result.Result == "success" {
		mc.token = result.Token
		return nil
	}
	return fmt.Errorf("autenticación fallida")
}

func (mc *MetasploitClient) makeRequest(method string, params interface{}) ([]byte, error) {
	reqBody := map[string]interface{}{
		"method": method,
		"params": params,
	}
	if mc.token != "" {
		reqBody["token"] = mc.token
	}
	jsonData, err := json.Marshal(reqBody)
	if err != nil {
		return nil, err
	}
	resp, err := mc.client.Post(mc.baseURL, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return body, nil
}

func (mc *MetasploitClient) ExecuteExploit(req ExploitRequest) (*ExploitResult, error) {
	params := map[string]interface{}{
		"module_type": "exploit",
		"module_name": req.Module,
		"options": map[string]string{
			"RHOSTS":  req.Target,
			"PAYLOAD": req.Payload,
		},
	}
	for k, v := range req.Options {
		params["options"].(map[string]string)[k] = v
	}
	response, err := mc.makeRequest("module.execute", params)
	if err != nil {
		return nil, fmt.Errorf("error ejecutando exploit: %w", err)
	}
	var rawResult map[string]interface{}
	if err := json.Unmarshal(response, &rawResult); err != nil {
		return nil, err
	}
	result := &ExploitResult{
		Module:    req.Module,
		Target:    req.Target,
		Timestamp: time.Now(),
	}
	if job, ok := rawResult["job_id"]; ok && job != nil {
		result.Success = true
		result.SessionID = fmt.Sprintf("%v", job)
		result.Output = "Exploit ejecutado exitosamente"
	} else {
		result.Success = false
		result.Output = "Exploit falló"
	}
	return result, nil
}
