package msf

import (
	"fmt"

	"github.com/juanotejeda/REStrike/pkg/models"
)

// ExploitSuggestion sugerencia de exploit
type ExploitSuggestion struct {
	ModuleName  string
	Description string
	Rank        string
	Target      string
	Port        int
	Service     string
}

// SuggestExploits sugiere exploits basados en resultados de escaneo
func SuggestExploits(client *Client, result *models.ScanResult) ([]ExploitSuggestion, error) {
	var suggestions []ExploitSuggestion
	searched := make(map[string]bool) // Para evitar duplicados

	for _, host := range result.Hosts {
		for _, port := range host.Ports {
			if port.State != "open" {
				continue
			}

			// Buscar por múltiples términos
			searchTerms := []string{
				port.Service,
				fmt.Sprintf("%s %d", port.Service, port.ID),
			}
			
			// Agregar versión si existe
			if port.Version != "" {
				searchTerms = append(searchTerms, fmt.Sprintf("%s %s", port.Service, port.Version))
			}

			for _, term := range searchTerms {
				if term == "" || searched[term] {
					continue
				}
				searched[term] = true

				// Buscar exploits para este servicio
				exploits, err := client.GetExploits(term, port.ID)
				if err != nil {
					continue
				}

				for _, exploit := range exploits {
					name, ok := exploit["name"].(string)
					if !ok {
						continue
					}
					
					description := "N/A"
					rank := "unknown"
					
					if info, ok := exploit["info"].(map[string]interface{}); ok {
						if desc, ok := info["description"].(string); ok {
							description = desc
						} else if descBytes, ok := info["description"].([]byte); ok {
							description = string(descBytes)
						}

						if r, ok := info["rank"].(string); ok {
							rank = r
						} else if rBytes, ok := info["rank"].([]byte); ok {
							rank = string(rBytes)
						}
					}

					suggestions = append(suggestions, ExploitSuggestion{
						ModuleName:  name,
						Description: description,
						Rank:        rank,
						Target:      host.IP,
						Port:        port.ID,
						Service:     port.Service,
					})
				}
			}
		}
	}

	return suggestions, nil
}

// ExecuteExploit ejecuta un exploit contra un target
func ExecuteExploit(client *Client, suggestion ExploitSuggestion, lhost string, lport int) (string, error) {
	options := map[string]string{
		"RHOSTS": suggestion.Target,
		"RPORT":  fmt.Sprintf("%d", suggestion.Port),
		"LHOST":  lhost,
		"LPORT":  fmt.Sprintf("%d", lport),
	}

	result, err := client.ExecuteModule("exploit", suggestion.ModuleName, options)
	if err != nil {
		return "", err
	}

	if jobID, ok := result["job_id"].(string); ok {
		return fmt.Sprintf("Exploit ejecutado. Job ID: %s", jobID), nil
	}

	return "Exploit ejecutado", nil
}
